package de.thb.dim.pizzaProntoTest;import static org.junit.jupiter.api.Assertions.assertNotNull;import static org.junit.jupiter.api.Assertions.assertNull;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import java.io.ByteArrayOutputStream;import java.io.PrintStream;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.time.LocalDate;import java.time.LocalDateTime;import java.util.ArrayList;import java.util.List;import org.junit.jupiter.api.Assertions;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import de.thb.dim.pizzaPronto.businessObjects.Delivery;import de.thb.dim.pizzaPronto.businessObjects.IService;import de.thb.dim.pizzaPronto.businessObjects.Kitchen;import de.thb.dim.pizzaPronto.businessObjects.Ordering;import de.thb.dim.pizzaPronto.businessObjects.exceptions.NoCustomerException;import de.thb.dim.pizzaPronto.businessObjects.exceptions.NoOrderException;import de.thb.dim.pizzaPronto.valueObjects.CustomerVO;import de.thb.dim.pizzaPronto.valueObjects.DessertVO;import de.thb.dim.pizzaPronto.valueObjects.DishVO;import de.thb.dim.pizzaPronto.valueObjects.Gender;import de.thb.dim.pizzaPronto.valueObjects.OrderVO;import de.thb.dim.pizzaPronto.valueObjects.PastaVO;import de.thb.dim.pizzaPronto.valueObjects.PizzaVO;import de.thb.dim.pizzaPronto.valueObjects.StateOfOrderVO;import de.thb.dim.pizzaPronto.valueObjects.exceptions.CustomerNoDateOfBirthException;import de.thb.dim.pizzaPronto.valueObjects.exceptions.CustomerTooYoungException;/** * EmployeeVO and work are tested. *  * Requirement: OrderVO and menuVO are ok *  * Special assert statements are used for testing <br> *  * @author Gabriele Schmidt * @version 2.0 03.05.2020 */public class JUnitTestOrdering {	private static Class<Ordering> myOrderingClass;	private static OrderVO myOrder;	private static OrderVO myOrderWithoutCustomer;	private static Ordering myOrdering;	private static IService[] services = new IService[2];	private static CustomerVO customer;		private static Field nextId;	private static int modifiersNextId;		private static Field menu;	private static int modifiersMenu;			private final ByteArrayOutputStream outContent = new ByteArrayOutputStream();	private final ByteArrayOutputStream errContent = new ByteArrayOutputStream();	private final PrintStream originalOut = System.out;	private final PrintStream originalErr = System.err;		@BeforeEach	public void initEach() throws NoSuchFieldException, NoSuchMethodException, SecurityException, NullPointerException, CustomerTooYoungException {		int year, number;		// create chef		services[0] = new Kitchen();		// create delivery man		services[1] = new Delivery();		// create customer		customer = new CustomerVO("Genuss", "Gini", "Haribostra√üe", 32, Gender.F, LocalDate.of(1995, 8, 8));		// create order		year = LocalDate.now().getYear();		number = year * 100000 + 1;		myOrder = new OrderVO(number, StateOfOrderVO.STARTED, LocalDateTime.now(), customer);		customer.setOrder(myOrder);		myOrderWithoutCustomer = new OrderVO(number, StateOfOrderVO.STARTED, LocalDateTime.now(), null);		myOrdering = new Ordering();				myOrderingClass = Ordering.class;		nextId = myOrderingClass.getDeclaredField("nextId");		modifiersNextId = nextId.getModifiers();			}	// Ordering		@Test	@DisplayName("test attribut menu of Ordering is not null")	public void testOrderingCreateMenu()  {		assertNotNull(Ordering.getMenu(), "Attribut menu of Ordering is not null");;			}		@Test	@DisplayName("test attribut menu of Ordering is private")	public void testOrderingMenuPrivate() throws NoSuchFieldException, SecurityException {		myOrderingClass = Ordering.class;		menu = myOrderingClass.getDeclaredField("menu");		modifiersMenu = menu.getModifiers();		assertTrue(Modifier.isPrivate(modifiersMenu), "Attribut menu of Ordering is private");	}		@Test	@DisplayName("test attribut menu of Ordering is static")	public void testOrderingMenuStatic() throws NoSuchFieldException, SecurityException {		myOrderingClass = Ordering.class;		menu = myOrderingClass.getDeclaredField("menu");		modifiersMenu = menu.getModifiers();		assertTrue(Modifier.isStatic(modifiersMenu), "Attribut menu of Ordering is static");	}		@Test	@DisplayName("test nextId is private")	public void testnextIdPrivate() {		assertTrue( Modifier.isPrivate(modifiersNextId),"NextId is private" );	}		@Test	@DisplayName("test nextId is static")	public void nextId() {		assertTrue( Modifier.isStatic(modifiersNextId),"NextId is static" );	}		@Test	@DisplayName("test orderNo: Number contains the actual year")	public void testorderNoYear() {		int test = myOrder.getOrderNo();		String s = Integer.toString(test);		String year = Integer.toString(LocalDate.now().getYear());		assertTrue(s.contains(year), "Correc year is part of the identifier");	}		@Test	@DisplayName("test orderNo of currentOrder is correct and nextId of Ordering is correct when starting with 0")	public void testOrderingNextId0() throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {		int id = 0;		Ordering myOrderingId = new Ordering();		myOrderingClass = Ordering.class;		nextId = myOrderingClass.getDeclaredField("nextId");		nextId.setAccessible(true);		nextId.set(0, 0);		assertTrue(id == Ordering.getNextId(), "NexID is 0");		myOrderingId.startNewOrder(customer);		id = LocalDateTime.now().getYear() * 100000 + 1;		assertTrue(id == myOrderingId.getCurrentOrder().getOrderNo(), "OrderNo of currentOrder is correct");		assertTrue(id == Ordering.getNextId(), "NextId of Ordering is correct");			}	@Test	@DisplayName("test nextId of Ordering is correctly incremented")	public void testOrderingNextIdIncrement() throws NoSuchFieldException, SecurityException {		int id;		Ordering myOrderingId = new Ordering();		id = Ordering.getNextId();		for (int i = 0; i < 20; i++) {			myOrderingId.startNewOrder(customer);			id++;			assertTrue(id == Ordering.getNextId(), "NextId of Ordering is correct");		}	}		@Test	@DisplayName("test constructor of Ordering initializes the associated attributes.")	public void testOrderingConstruktor() {				OrderVO order;		CustomerVO customer;				IService services [] = new IService[2];		myOrdering = new Ordering();				order = myOrdering.getCurrentOrder();		assertNull(order,"Order is null");				customer = myOrdering.getCurrentCustomer();		assertNull(customer,"Customer is null");				services[0] = myOrdering.getKitchen();		assertNotNull(services[0],"Kitchen is not null");				services[1] = myOrdering.getDelivery();		assertNotNull(services[1],"Delivery is not null");			}		@Test	@DisplayName("test start a new order")	public void testOrderingStartNewOrder() {				OrderVO order;			order = myOrdering.startNewOrder(customer);		assertNotNull(order,"return value  is not null");		assertTrue(order.equals(myOrdering.getCurrentOrder()), "CurrentOrder is set and matches the return value. ");		assertTrue(customer.equals(myOrdering.getCurrentCustomer()), "CurrentCustomer is set and matches the parameter. ");		assertTrue(order.equals(myOrdering.getCurrentCustomer().getOrder()), "Order in customer is set and the order. ");		assertTrue(order.getState().equals(StateOfOrderVO.STARTED), "State of order  is StateOfOrderVO.STARTED. ");			}		@Test	@DisplayName("test start a new order with no customer")	public void testOrderingStartNewOrderWithNoCustomer() {						Exception exception = Assertions.assertThrows(NullPointerException.class,				() -> myOrdering.startNewOrder(null));		assertEquals("Customer must not be null.", exception.getMessage());	}	@Test	@DisplayName("test last nextId is set to the year before, new nextId is correctly calculated")	public void testOrderingNextIdNewYear()			throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {		int id;		Ordering myOrderingId = new Ordering();		myOrderingClass = Ordering.class;		nextId = myOrderingClass.getDeclaredField("nextId");		nextId.setAccessible(true);		nextId.set((LocalDateTime.now().getYear() - 1) * 100000 + 1, (LocalDateTime.now().getYear() - 1) * 100000 + 1);				myOrderingId.startNewOrder(customer);		id = LocalDateTime.now().getYear() * 100000 + 1;		assertTrue(id == myOrderingId.getCurrentOrder().getOrderNo(), "OrderNo of currentOrder is correct");		assertTrue(id == Ordering.getNextId(), "NextId of Ordering is correct");	}			@Test	@DisplayName("test add dish with no order")	public void testOrderingAddDishWithNoOrder() {	    			myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows(NoOrderException.class,				() -> myOrdering.addDish(new DessertVO()));		assertEquals("There is no order.", exception.getMessage());	}		@Test	@DisplayName("test add dish with no customer")	public void testOrderingAddDishWithNoCustomer() {	    			myOrdering.setCurrentCustomer(null);				Exception exception = Assertions.assertThrows(NoOrderException.class,				() -> myOrdering.addDish(new DessertVO()));		assertEquals("There is no order.", exception.getMessage());	}			@Test	@DisplayName("test add dish")	public void testOrderingAddDish() throws IllegalStateException, NoOrderException{	   		DishVO dish = new DessertVO();		OrderVO order;			order = myOrdering.startNewOrder(customer);		myOrdering.addDish(dish);		assertEquals(dish, order.getDish(0),"Dish is added");	}		@Test	@DisplayName("test add dish with state is StateOfOrderVO.CONFIRMED")	public void testOrderingAddDishStateConfirmed() {	   		DishVO dish = new DessertVO();		OrderVO order;			order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.CONFIRMED);				Exception exception = Assertions.assertThrows(IllegalStateException.class,				() -> myOrdering.addDish(dish));		assertEquals("Your order is complete, you can not add any dishes.", exception.getMessage());	}		@Test	@DisplayName("test add dish with state is StateOfOrderVO.READY")	public void testOrderingAddDishStateReady() {				DishVO dish = new DessertVO();		OrderVO order;			order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.READY);		Exception exception = Assertions.assertThrows(IllegalStateException.class,				() -> myOrdering.addDish(dish));		assertEquals("Your order is complete, you can not add any dishes.", exception.getMessage());	}		@Test	@DisplayName("test add dish with state is StateOfOrderVO.DELIVERED")	public void testOrderingAddDishStateDelivered() {		 		DishVO dish = new DessertVO();		OrderVO order;			order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.DELIVERED);			Exception exception = Assertions.assertThrows(IllegalStateException.class,				() -> myOrdering.addDish(dish));		assertEquals("Your order is complete, you can not add any dishes.", exception.getMessage());	}		@Test	@DisplayName("test add dish with state is finished")	public void testOrderingAddDishStateFinished() {				DishVO dish = new DessertVO();		OrderVO order;			order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.FINISHED);					Exception exception = Assertions.assertThrows(IllegalStateException.class,				() -> myOrdering.addDish(dish));		assertEquals("Your order is complete, you can not add any dishes.", exception.getMessage());	}		@Test	@DisplayName("test add dish with dish is null")	public void testOrderingAddDishNull() throws IllegalStateException, NoOrderException{	   		DishVO dish = null;		OrderVO order;			order = myOrdering.startNewOrder(customer);		myOrdering.addDish(dish);		assertEquals(dish, order.getDish(0),"Dish is added");	}		@Test	@DisplayName("test delete dish with no order")	public void testOrderingDeleteDishWithNoOrder() throws IllegalStateException {	    			myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows(NoOrderException.class,				() -> myOrdering.deleteDish(new DessertVO()));		assertEquals("There is no order.", exception.getMessage());	}		@Test	@DisplayName("test delete dish deleting last dish")	public void testOrderingDeleteDish() throws IllegalStateException, NoOrderException{	   		DishVO dish = new DessertVO();		OrderVO order;			order = myOrdering.startNewOrder(customer);		myOrdering.addDish(dish);		assertEquals(dish, order.getDish(0),"Dish is added");		myOrdering.deleteDish(dish);		assertEquals(0, order.getNumberOfDishes(),"Dish is delete. There are no more dishes");	}		@Test	@DisplayName("test delete dish with state is StateOfOrderVO.CONFIRMED")	public void testOrderingDeleteDishStateConfirmed() {				OrderVO order;			order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.CONFIRMED);				Exception exception = Assertions.assertThrows(IllegalStateException.class,				() -> myOrdering.deleteDish(new DessertVO()));		assertEquals("Your order is complete, you can not delete any dishes.", exception.getMessage());	}		@Test	@DisplayName("test delete dish with state is StateOfOrderVO.DELIVERED")	public void testOrderingDeleteDishStateDelivered() {				OrderVO order;			order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.DELIVERED);				Exception exception = Assertions.assertThrows(IllegalStateException.class,				() -> myOrdering.deleteDish(new DessertVO()));		assertEquals("Your order is complete, you can not delete any dishes.", exception.getMessage());	}		@Test	@DisplayName("test delete dish with state is StateOfOrderVO.FINISHED")	public void testOrderingDeleteDishStateFinished() {				OrderVO order;			order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.FINISHED);				Exception exception = Assertions.assertThrows(IllegalStateException.class,				() -> myOrdering.deleteDish(new DessertVO()));		assertEquals("Your order is complete, you can not delete any dishes.", exception.getMessage());	}		@Test	@DisplayName("test delete dish with state is StateOfOrderVO.READY")	public void testOrderingDeleteDishStateReady() {				OrderVO order;			order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.READY);				Exception exception = Assertions.assertThrows(IllegalStateException.class,				() -> myOrdering.deleteDish(new DessertVO()));		assertEquals("Your order is complete, you can not delete any dishes.", exception.getMessage());	}		@Test	@DisplayName("test confirm order results in state \"finisded\" and correct output of order on the console")	public void testOrderingConfirmOrder() throws IllegalStateException, NoOrderException, NoCustomerException{		System.setOut(new PrintStream(outContent));		OrderVO order;		order = myOrdering.startNewOrder(customer);		myOrdering.confirmOrder();		assertEquals(StateOfOrderVO.FINISHED,order.getState(), "State of order is finished, since service is StateOfOrderVO.STARTED.");  		assertTrue(outContent.toString().contains("Order completed: " + order.toString()), "Your order can not be processed.");		   System.setOut(originalOut);	}		@Test	@DisplayName("test start service with state is \"StateOfOrderVO.FINISHED\" at the ende and correct output of order on the console")	public void testOrderingStartServiceStateFinishedAtEnd() throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IllegalStateException, NoOrderException, NoCustomerException{		System.setOut(new PrintStream(outContent));		OrderVO currentOrder;		myOrdering.startNewOrder(customer);		myOrdering.confirmOrder();		Method m = Ordering.class.getDeclaredMethod("startService");		// Using setAccessible() method		m.setAccessible(true);		// Using invoke() method		m.invoke(myOrdering);		    currentOrder = myOrdering.getCurrentOrder();		assertTrue(outContent.toString().contains("Order completed: " + currentOrder.toString()), "Your order can not be processed.");	   System.setOut(originalOut);	  	}		@Test	@DisplayName("test text of StateOfOrderVO.CONFIRMED order is  \"Order completed: \" at the end")	public void testOrderingConfirmOrderTextAtEnd() throws IllegalStateException, NoOrderException, NoCustomerException{		System.setOut(new PrintStream(outContent));	    System.setErr(new PrintStream(errContent));	    myOrdering.startNewOrder(customer);		myOrdering.confirmOrder();		assertTrue(outContent.toString().contains("Order completed: "), "Order completed: ");		System.setOut(originalOut);		System.setErr(originalErr);	}		@Test	@DisplayName("test confirm order with no order")	public void testOrderingConfirmOrderNull() throws IllegalStateException, NoCustomerException{			myOrdering.setCurrentOrder(null);	  		Exception exception = Assertions.assertThrows(NoOrderException.class,				() -> myOrdering.confirmOrder());		assertEquals("There is no order.", exception.getMessage());	}				@Test	@DisplayName("test start service with no order")	public void testOrderingStartServiceOrderNULL() throws NoSuchMethodException, SecurityException{	    			myOrdering.setCurrentOrder(null);						Method m = Ordering.class.getDeclaredMethod("startService");		// Using setAccessible() method		m.setAccessible(true);		// Using invoke() method		Exception exception = Assertions.assertThrows(InvocationTargetException.class, () -> m.invoke(myOrdering));				assertEquals(NoOrderException.class, exception.getCause().getClass());		assertEquals("There is no order.", exception.getCause().getMessage());	}		@Test	@DisplayName("test start service with no customer")	public void testOrderingStartServiceNoCustomer() throws NoSuchMethodException, SecurityException{	    		myOrdering.setCurrentCustomer(null);				Method m = Ordering.class.getDeclaredMethod("startService");		// Using setAccessible() method		m.setAccessible(true);		// Using invoke() method		Exception exception = Assertions.assertThrows(InvocationTargetException.class, () -> m.invoke(myOrdering));				assertEquals(NoOrderException.class, exception.getCause().getClass());		assertEquals("There is no order.", exception.getCause().getMessage());	}			@Test	@DisplayName("test start service with state is \"StateOfOrderVO.STARTED\"")	public void testOrderingStartServiceStateStarted() throws NoSuchMethodException, SecurityException{		  myOrdering.startNewOrder(customer);				Method m = Ordering.class.getDeclaredMethod("startService");		// Using setAccessible() method		m.setAccessible(true);		// Using invoke() method		Exception exception = Assertions.assertThrows(InvocationTargetException.class, () -> m.invoke(myOrdering));				assertEquals(IllegalStateException.class, exception.getCause().getClass());		assertEquals("The order can not be processed.", exception.getCause().getMessage());				 	}		@Test	@DisplayName("test calculate total price with no order.")	public void testOrderingCalculateTotalPriceOrderNull() throws NoOrderException{		myOrdering.setCurrentOrder(null);				Exception exception = Assertions.assertThrows(NoOrderException.class,				() -> myOrdering.calculateTotalPrice());		assertEquals("There is no order.", exception.getMessage());	}		@Test	@DisplayName("test calculate total price with no dish.")	public void testOrderingCalculateTotalPriceOrderNoDish() throws NoOrderException{		float price;					myOrdering.startNewOrder(customer);			price = myOrdering.calculateTotalPrice();			assertTrue(0.0f == price, "Price is 0.");	}				@Test	@DisplayName("test calculate total price with state is \"StateOfOrderVO.CONFIRMED\".")	public void testOrderingCalculateTotalPriceOrderStateConfirmed() throws NoOrderException {		float price;		OrderVO order;		order = myOrdering.startNewOrder(customer);		order.setState(StateOfOrderVO.CONFIRMED);		price = myOrdering.calculateTotalPrice();		assertTrue(0.0f == price, "Price is 0.");	}		@Test	@DisplayName("test calculate total price.")	public void testOrderingCalculateTotalPrice() throws IllegalStateException, NoOrderException {		float priceIni =  7.65f;		float price;		OrderVO order;		DishVO dish = new PizzaVO(30, "Popeye", new String[] { "Schinken",				"Spinat", "Champignon", "Ei" }, priceIni, 1);		order = myOrdering.startNewOrder(customer);		myOrdering.addDish(dish);		price = myOrdering.calculateTotalPrice();		assertTrue(priceIni == price, "Total price is ok.");		order.setState(StateOfOrderVO.CONFIRMED);		price = myOrdering.calculateTotalPrice();		assertTrue(priceIni == price, "Total price is ok.");	}		@Test	@DisplayName("Sort is correct according to total ordering, i.e. by name.")	public void sortShoppingBasket() throws NoOrderException {		List<DishVO> shoppingBasketInit, shoppingBasketSort, shoppingBasketSortExcpeted;		OrderVO order;		Ordering ordering;				shoppingBasketInit = new ArrayList<DishVO>();		shoppingBasketSortExcpeted = new ArrayList<DishVO>();				ordering = new Ordering();				order = ordering.startNewOrder(customer);				shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 1));		shoppingBasketInit.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketInit.add(new PizzaVO(30, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));				shoppingBasketSortExcpeted.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 1));				order.setShoppingBasket(shoppingBasketInit);		shoppingBasketSort = ordering.sortShoppingBasket();		assertEquals(shoppingBasketSort, shoppingBasketSortExcpeted);	}		@Test	@DisplayName("Sort is by total ordering, i.e. by name, but there is no order")	public void sortShoppingBasketNoOrder() throws NoOrderException {				Ordering ordering;				ordering = new Ordering();				Exception exception = Assertions.assertThrows(NoOrderException.class,				() ->ordering.sortShoppingBasket());		assertEquals("There is no order.", exception.getMessage());	}		@Test	@DisplayName("Sort is correct by number")	public void sortShoppingBasketByNumber() throws NoOrderException {		List<DishVO> shoppingBasketInit, shoppingBasketSort, shoppingBasketSortExcpeted;		OrderVO order;		Ordering ordering;				shoppingBasketInit = new ArrayList<DishVO>();		shoppingBasketSortExcpeted = new ArrayList<DishVO>();				ordering = new Ordering();				order = ordering.startNewOrder(customer);						shoppingBasketInit.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 1));		shoppingBasketInit.add(new PizzaVO(31, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));						shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 1));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketSortExcpeted.add(new PizzaVO(31, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 3.5f, 2));		shoppingBasketSortExcpeted.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));				order.setShoppingBasket(shoppingBasketInit);		shoppingBasketSort = ordering.sortShoppingBasketByNumber();		assertEquals(shoppingBasketSort, shoppingBasketSortExcpeted);	}		@Test	@DisplayName("Sort is by number, but there is no order")	public void sortShoppingBasketByNumberNoOrder() throws NoOrderException {				Ordering ordering;				ordering = new Ordering();				Exception exception = Assertions.assertThrows(NoOrderException.class,				() -> ordering.sortShoppingBasketByNumber());		assertEquals("There is no order.", exception.getMessage());	}		@Test	@DisplayName("Sort is correct by price")	public void sortShoppingBasketByPrice() throws NoOrderException {		List<DishVO> shoppingBasketInit, shoppingBasketSort, shoppingBasketSortExcpeted;		OrderVO order;		Ordering ordering;				shoppingBasketInit = new ArrayList<DishVO>();		shoppingBasketSortExcpeted = new ArrayList<DishVO>();				ordering = new Ordering();				order = ordering.startNewOrder(customer);						shoppingBasketInit.add(new PizzaVO(31, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 8.5f, 2));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 7.5f, 2));		shoppingBasketInit.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 6.5f, 1));		shoppingBasketInit.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));					shoppingBasketSortExcpeted.add(new PastaVO(12, "Z",	new String[] { "Hackfleischsauce" }, 6.40f, 4));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 6.5f, 1));		shoppingBasketSortExcpeted.add(new PizzaVO(30, "X", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 7.5f, 2));		shoppingBasketSortExcpeted.add(new PizzaVO(31, "A", new String[] { "Schinken", "Spinat", "Champignon", "Ei" }, 8.5f, 2));						order.setShoppingBasket(shoppingBasketInit);		shoppingBasketSort = ordering.sortShoppingBasketByPrice();		assertEquals(shoppingBasketSort, shoppingBasketSortExcpeted);	}		@Test	@DisplayName("Sort is by price, but there is no order")	public void sortShoppingBasketByPriceNoOrder() throws NoOrderException {				Ordering ordering;				ordering = new Ordering();				Exception exception = Assertions.assertThrows(NoOrderException.class,				() -> ordering.sortShoppingBasketByPrice());		assertEquals("There is no order.", exception.getMessage());	}}