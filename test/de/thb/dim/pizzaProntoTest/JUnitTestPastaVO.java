package de.thb.dim.pizzaProntoTest;import static org.junit.jupiter.api.Assertions.assertArrayEquals;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertTrue;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import de.thb.dim.pizzaPronto.valueObjects.ChefVO;import de.thb.dim.pizzaPronto.valueObjects.PastaVO;/** * The methods of the class PastaVO are tested. *  * Special assert statements are used for testing <br> *  * @author Gabriele Schmidt * @version 2.0 04.02.2017 */public class JUnitTestPastaVO {	private static Class<PastaVO> myPastaVOClass;	private static PastaVO pastaX, pastaY, pastaZ;	@BeforeEach	public void initEach() {		pastaX = new PastaVO(11, "Napoli", new String[] { "Tomatensauce", "Basilikum" }, 5.60f, 4);		pastaY =  new PastaVO(pastaX.getNumber(),pastaX.getName(),pastaX.getIngredients(),pastaX.getPrice(),pastaX.getTypeOfPasta() );		pastaZ =  new PastaVO(pastaX.getNumber(),pastaX.getName(),pastaX.getIngredients(),pastaX.getPrice(),pastaX.getTypeOfPasta() );	}			@Test	@DisplayName("Class has 2 instance attributes")	public void test2Attributes() {		myPastaVOClass = PastaVO.class;		Field[] attributes = myPastaVOClass.getDeclaredFields();		assertEquals(2, attributes.length);	}		@Test	@DisplayName("Information hiding principle (Geheimnisprinzip): Attributes are private")	public void testAttributesPrivate() {		myPastaVOClass = PastaVO.class;		Field[] attributes = myPastaVOClass.getDeclaredFields();		int modifiersAttributes;		for (Field f : attributes) {			modifiersAttributes = f.getModifiers();			assertTrue(Modifier.isPrivate(modifiersAttributes));		}	}		@Test	@DisplayName("All Methods are public")	public void testMethodsPublic() {		myPastaVOClass = PastaVO.class;		Method[] methods = myPastaVOClass.getDeclaredMethods();		int modifiersMethods;		for (Method m : methods) {			modifiersMethods = m.getModifiers();			assertTrue(Modifier.isPublic(modifiersMethods));		}	}		@Test	@DisplayName("Default constructor initializes with default values")	public void testDefaultConstructor() {		PastaVO pastaWithout = new PastaVO();		assertEquals(null, pastaWithout.getName());		assertEquals(0.0f, pastaWithout.getPrice());		assertEquals(null, pastaWithout.getIngredients());	}		@Test	@DisplayName("Initialization constructor with 5 parameters")	public void testIniConstructor() {		float price = 2.020f;		String name = "tonno prima";		String [] ingredis = {"Tomaten","K채se","Basilikum"};		int type = 1;		int no = 23;				PastaVO pastaIni = new PastaVO(no, name, ingredis, price, type);		assertEquals(no, pastaIni.getNumber());		assertEquals(name, pastaIni.getName());		assertEquals(ingredis, pastaIni.getIngredients());		assertEquals(price, pastaIni.getPrice());		assertEquals(type, pastaIni.getTypeOfPasta());	}		@Test	@DisplayName("Initializing Constructor: Price should not be negative and is set to 0.")	public void testIniConstructorPriceNegative() {		PastaVO pastaIni =  new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, -7.00f, 1);		assertTrue(				pastaIni.getPrice() >= 0,pastaIni.getClass() + " not a negative price ");			}		@Test	@DisplayName("Initializing Constructor: Price is 0.")	public void testIniConstructorPrice0() {		PastaVO pastaIni = new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 0.00f, 1);;		assertTrue(				pastaIni.getPrice() >= 0,pastaIni.getClass() + " not a negative price ");			}		@Test	@DisplayName("compareTo is tested < 0 and equals false")	public void compareToLess0() {			PastaVO pastaA = new PastaVO(32, "A", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 0.00f, 1);		PastaVO pastaB =new PastaVO(32, "B", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 0.00f, 1);		assertTrue(pastaA.compareTo(pastaB) < 0);		assertFalse(pastaA.equals(pastaB));	}		@Test	@DisplayName("compareTo is tested == 0 and equals true")	public void compareToEquals0() {			PastaVO pastaA = new PastaVO(32, "A", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 0.00f, 1);		PastaVO pastaB = new PastaVO(32, "A", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 0.00f, 1);		assertTrue(pastaA.compareTo(pastaB) == 0);		assertTrue(pastaA.equals(pastaB));	}		@Test	@DisplayName("compareTo is tested > 0 and equals false")	public void compareToBigger0() {			PastaVO pastaA = new PastaVO(32, "A", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 0.00f, 1);		PastaVO pastaB = new PastaVO(32, "B", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 0.00f, 1);		assertTrue(pastaB.compareTo(pastaA) > 0);		assertFalse(pastaA.equals(pastaB));	}			//Java default opertions	@Test	@DisplayName("equals is tested with null")	public void equalsNull() {			//For any non-null reference value x, x.equals(null) should return false. 		assertFalse( pastaX.equals(null),"For any non-null reference value x, x.equals(null) should return false.");	}		@Test	@DisplayName("equals is tested with two equal/similar objects, i.e different adresses and similar attributes. ")	public void equals2EqualObjects() {		assertFalse(pastaY == pastaX);		assertTrue( pastaY.equals(pastaX));	}	@Test	@DisplayName("equals is tested with  identical objects. ")	public void equals2IdenticalObjects() {			assertTrue(pastaY.equals(pastaY));	}			@Test	@DisplayName("equals is tested with three equal objects. Is it reflexive, symmetric and transitive according to the contract ")	public void equals3EqualObjects() {				//It is reflexive: for any non-null reference value x, x.equals(x) should return true. 		assertTrue(pastaY.equals(pastaY),"It is reflexive: for any non-null reference value x, x.equals(x) should return true. ");				//It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.  		assertTrue(pastaX.equals(pastaY) == pastaY.equals(pastaX),"It is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true. ");					//It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.   		assertTrue((pastaX.equals(pastaY) && pastaY.equals(pastaZ)) ? pastaX.equals(pastaZ): false,"It is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. ");		}			@Test	@DisplayName("equals is tested different objects.")	public void equalsDifferentObjects() {					pastaZ.setName("Anders");		assertFalse(pastaZ.equals(pastaX),pastaZ.getClass() + " equals is correct when using diffenrent objects of the same class");	}		@Test		@DisplayName("equals is tested different objects from different classes.")		public void equalsDifferentObjectsDifferentClasses() {					assertFalse(pastaZ.equals(new ChefVO()),pastaZ.getClass() + " equals is not correct when using objects from differnent class.");	}		@Test	@DisplayName("equals is tested with 2 objects created by default constructor.")	public void equalsDefaultConstructors() {				PastaVO default1, default2;		default1 = new PastaVO();		default2 = new PastaVO();		assertTrue(default1.equals(default2));	}		@Test	@DisplayName("clone is tested with 2 objects, equals should be correct .")	public void cloneDetailed() {		pastaX =  new PastaVO(12, "Bolognese",new String[] { "Hackfleischsauce" }, 6.40f, 4);		pastaY = (PastaVO) pastaX.clone();				//For any non-null reference value x, x.equals(null) should return false. 		assertFalse( pastaX.equals(null),"For any non-null reference value x, x.equals(null) should return false.");						//Two Objects		assertTrue( pastaY != pastaX);				//Equals		assertTrue( pastaY.equals(pastaX));				assertTrue( pastaY.equals(pastaX));			}				@Test	@DisplayName("Clone is tested with equals, i.e. the equals tests should be correct.")	public void cloneSimple() {		PastaVO pastaClone;		PastaVO pastaIni = new PastaVO(12, "Bolognese",new String[] { "Hackfleischsauce" }, 6.40f, 4);		pastaClone = (PastaVO) pastaIni.clone();				assertTrue(pastaIni != pastaClone);		assertTrue(pastaIni.equals(pastaClone));			}		@Test		@DisplayName("clone is tested with 2 objects. Is should be a deep copy")	public void cloneDeepCopy() {		pastaX =  new PastaVO(12, "Bolognese",new String[] { "Hackfleischsauce" }, 6.40f, 4);		pastaY = (PastaVO) pastaX.clone();				assertEquals( pastaY.getName(),pastaX.getName());		assertEquals( pastaY.getNameOfDish(),pastaX.getNameOfDish());		assertEquals( pastaY.getNumber(),pastaX.getNumber());		assertEquals( pastaY.getNumberOfDish(),pastaX.getNumberOfDish());		assertEquals( pastaY.getPrice(),pastaX.getPrice());		assertEquals(((PastaVO)pastaY).getTypeOfPasta(),((PastaVO)pastaY).getTypeOfPasta());		assertArrayEquals( pastaY.getIngredients(),pastaX.getIngredients());				}		@Test	@DisplayName("equals is tested with other object created by initalizing construct and this object created by default construct and.")	public void equalsIniAndDefaultConstructors() {				PastaVO ini, default2;		ini =  new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 7.00f, 1);;		default2 = new PastaVO();		assertFalse(ini.equals(default2));	}		@Test	@DisplayName("equals is tested with this name and other other name is null.")	public void equalsOtherNameNull() {				PastaVO ini, other;		ini =  new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 7.00f, 1);		other =  new PastaVO(32, null, new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 7.00f, 1);		assertFalse(ini .equals(other));	}		@Test	@DisplayName("equals is tested with this name is null and other  name.")	public void equalsThisNameNull() {				PastaVO ini, other;		ini =  new PastaVO(32, null, new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 7.00f, 1);		other =  new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 7.00f, 1);		assertFalse(ini .equals(other));	}		@Test	@DisplayName("equals is tested with this price and other price is 0.")	public void equalsOtherPrice0() {				PastaVO ini, other;		ini =  new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 7.00f, 1);		other = new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 0.00f, 1);		assertFalse(ini .equals(other));	}		@Test	@DisplayName("equals is tested with this price is 0 and other price.")	public void equalsThisPrice0() {				PastaVO ini, other;		ini =  new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 0.00f, 1);		other = new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 7.00f, 1);		assertFalse(ini .equals(other));	}		@Test	public void testPastaVOEqualsHashCode() {		//Simliar objects provide similar hashcode		assertTrue(pastaX.equals(pastaY) == ( pastaX.hashCode() == pastaY.hashCode()),"Gleiche Objekte liefern den gleichen HashCode");		}		@Test	@DisplayName("test toString: Contains all attributes")	public void toStringTest() {		float price = 13.95f;		String name = "BBB";		String [] ingredients = {"Tomaten","K채se","Basilikum","Pfeffer"};		PastaVO pasta = new PastaVO();		pasta.setName(name);		pasta.setIngredients(ingredients);		pasta.setPrice(price);		pasta.setTypeOfPasta(5);				String actualString = pasta.toString();		 	    assertTrue(actualString.contains(name));	    for(String i : ingredients) {	    	assertTrue(actualString.contains(i));	    }	    assertTrue(actualString.contains(String.valueOf(13)));	    assertTrue(actualString.contains(String.valueOf(95)));	    assertTrue(actualString.contains("Pasta"));	    assertTrue(actualString.contains(name));	    assertTrue(actualString.contains("Tortellini"));	}			//Setter/Getter	@Test	@DisplayName("Information hiding principle (Geheimnisprinzip): Setter/getter name")	public void setGetName() {		String name = "BBB";		PastaVO pastaWithout = new PastaVO();		pastaWithout.setName(name);		assertEquals(name, pastaWithout.getName());	}		@Test	@DisplayName("Information hiding principle (Geheimnisprinzip): Setter/getter ingredients")	public void setGetIngredients() {		String [] ingredients = {"Tomaten","K채se","Basilikum","Pfeffer"};		PastaVO pastaWithout = new PastaVO();		pastaWithout.setIngredients(ingredients);		assertArrayEquals(ingredients, pastaWithout.getIngredients());	}				@Test	@DisplayName("Test ingredients with constructor")	public void testConstructorWithIngredients() {		PastaVO pastaIni =  new PastaVO(32, "Prima", new String[] { "Schinken", "Salami", "Zwiebeln", "Ei" }, 7.00f, 1);			assertArrayEquals( new String [] { "Schinken", "Salami", "Zwiebeln", "Ei" },pastaIni.getIngredients(),				pastaIni.getClass()				+ " checks the ingredients");	}		@Test	@DisplayName("Test ingredients with setter")	public void setIngredientsTest() {		String s [] = {"Tomaten","K채se","Anchovis"};		PastaVO pastaWithout = new PastaVO();		pastaWithout.setIngredients(s);				assertArrayEquals(s, pastaWithout.getIngredients(),				pastaWithout.getClass()				+ " checks the setter of ingredients");	}		@Test	@DisplayName("Information hiding principle (Geheimnisprinzip): Setter/getter price")	public void setGetPrice() {		float price = 2020.2020f;		PastaVO pastaWithout = new PastaVO();		pastaWithout.setPrice(price);		assertEquals(price, pastaWithout.getPrice());	}			@Test	@DisplayName("Information hiding principle (Geheimnisprinzip): Setter: Price should not be negative and is set to 0.")	public void setPriceNegative() {		PastaVO pastaWithout = new PastaVO();		pastaWithout.setPrice(-10.5f);		assertEquals(0f,pastaWithout.getPrice(), pastaWithout.getClass()				+ " checks the setter of price sets no negative price");	}		@Test	@DisplayName("Information hiding principle (Geheimnisprinzip):Setter: Price is 0.")	public void setPrice0() {		PastaVO pastaWithout = new PastaVO();		pastaWithout.setPrice(.0f);		assertEquals(0f,pastaWithout.getPrice(), pastaWithout.getClass()				+ " checks the setter of price sets no negative price");	}}